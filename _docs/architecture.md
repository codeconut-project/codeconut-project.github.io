---
title: Software architecture
permalink: /docs/architecture/
---

## The three subsystems of Codeconut

Codeconut consist of three subsystems:

1. Instrumenter
2. Runtime Helper
3. Analyzer

These three subsystems each have their own purpose during the process of collection code coverage metrics. Each subsystem is encapsulated and can be isolated from the other subsystems to allow for quick changes as long as the common interface between the subsystems doesn't get broken.


## Packaging

The instrumenter and analyzer are installed as one Python package, but are executed independently using the commands:

- "codeconut-instrumenter" for the instrumenter
- "codeconut-analyzer" for the analyzer

The runtime helper consists of a C file and the according header file, which are downloadable from the website.
It automatically get's included by every instrumented source file and should be placed inside a folder fitting the build process of the code that's to be analyzed.


## Use of the three subsystems

In the following section, the purpose of each subsystem get's explained briefly:


### Instrumenter

The instrumenter modifies a given input source file to accomodate the necessary calls to the runtime helper in order to generate the runtime information file. It also creates the [Codeconut Instrumentation Data file]({{site.baseurl}}{% link _docs/cid_format.md %}) that accomodates the links between the marker's and the statements/decisions/conditions of the source code.

The instrumenter should be used on non-preprocessed files only.

The instrumenter uses a parser that is able to detect the neccessary keywords in the code to instrumentize the code. Despite the greatest possible efforts to parse the code correctly, a correct instrumentation can't be guaranteed. In case of unsusual outputs, check the instrumentized source code file generated by the Codeconut instrumenter.

### Runtime Helper

The runtime helper includes functions responsible for writting the markers to the output file ([Codeconut Runtime Information]({{site.baseurl}}{% link _docs/cri_format.md %})).

The runtime helper generates a file pointer for each instrumented source code file. These pointers are used as the target for the output data of the runtime helper. For each function return, the output buffer is flushed to insure that the runtime information is stored when the program exits.


### Analyzer

TBD